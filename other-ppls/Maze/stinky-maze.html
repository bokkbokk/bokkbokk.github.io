<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>

<meta charset="utf-8" />

<title>Hyperbolic maze</title>

<style type="text/css">
/* <![CDATA[ */
#canvas { float: left; margin-right: 1em; margin-bottom: 1em; }
#please-wait { font-weight: bolder; }
#explanations { clear: left; display: none; }
.sidenote { font-size: .83em; }
address { text-align: right; }
/* ]]> */
</style>

</head>


<body>

<canvas id="canvas" width="600" height="600">
</canvas>

<h1>Hyperbolic maze</h1>

<p id="please-wait">Please stand by while the maze is being constructed…</p>

<p>Move with arrow keys and insert/delete.  (Also F1 to recenter.)
Or click in the direction in which you want to move.</p>

<p>Projection: <select id="projection-sel">
<option value="0">Poincaré disk</option>
<option value="1">Beltrami-Klein</option>
</select></p>

<p id="message"></p>

<p id="orbs"></p>

<p id="goal"></p>

<p>Bread crumbs: <select id="breadcrumbs-sel">
<option value="0">off</option>
<option value="1">on</option>
</select>, <input type="button" value="erase" id="breadcrumbs-erase" /></p>

<p>Beacons: <span id="beacons-list"></span></p>

<p>Show/hide <a id="show-explanations" href="hyperbolic-maze-2.html#explanations">explanations</a></p>

<script type="text/javascript">

// <![CDATA[

"use strict";

//// All of the following code was written by David A. Madore
////   (<URL: http://www.madore.org/~david/ >),
//// around 2014-12-11, and is hereby placed in the Public Domain.
////   (I would appreciate getting some thanks/recognition if it
////   is used elsewhere, but this is not a legal requirement,
////   just a polite request.)
//// It comes with no warranty whatsoever, of course.

// The Möbius transformations z -> (a*z + b)/(c*z + d) is represented
// as an array of 4 values: Re(a), Im(a), Re(b), Im(b); we normalize
// a*d-b*c=1 (note that there are still two equivalent representations
// of each, up to a global sign), and d and c are the conjugates of a
// and b respectively because we always preserve the unit circle.
var moebius_idn = [1,0,0,0];  // Identity matrix
var sqrt_half = Math.sqrt(2)/2;
var moebius_rot1 = [sqrt_half,sqrt_half,0,0];  // Hyperbolic rotation (R^4 = 1)
var moebius_rot2 = [0,1,0,0];  // R^2
var moebius_rot3 = [sqrt_half,-sqrt_half,0,0];  // R^3
var moebius_rottab = [moebius_idn, moebius_rot1, moebius_rot2, moebius_rot3];
// c ≈ 0.53063753095251782602 is the shortest side of the hyperbolic
// triangle with angles α=π/2, β=π/4 and γ=π/5.  So it is the distance
// between the center of one of the square tiles and the middle of one
// of its edges.
var cosh_c = 1.1441228056353685952001455671606041530723067536755;  // Root of x^4 - (3/2)*x^2 + 1/4
var sinh_c = 0.55589297025142117199204804789756925069105781499704;  // Root of x^4 + (1/2)*x^2 - 1/4
var moebius_trn = [cosh_c, 0, sinh_c, 0];  // Hyperbolic translation ((R*T)^5 = 1)
var moebius_tflip = [0, cosh_c, 0, -sinh_c];  // T*R^2
var cosh_half_c = 1.0354039804915201781233643210826166065182504353703;
var sinh_half_c = 0.26844255031139213493372738763232094175487323371651;
var tanh_half_c = 0.25926358732362497806075346395619478291118511605261;
var moebius_half_trn = [cosh_half_c, 0, sinh_half_c, 0];
var moebius_invhalf_trn = [cosh_half_c, 0, -sinh_half_c, 0];

// b ≈ 0.62686966290617781414 is another side of the same hyperbolic
// triangle.  So it is the half-length of one of the edges.
var tanh_half_b = 0.30355865872664673034932858948334224296408522601051;

// Bread crumbs position chosen so as to from an angle of γ/2=π/10 with vertex.
var cosh_half_cbd = 1.0120234025827606981773382966118882568588864795182;
var sinh_half_cbd = 0.1555357430791666388091670964785699319658882829791;
var breadcrumbs_trans = [cosh_half_cbd, 0, sinh_half_cbd, 0];

// The prime was chosen so as to split the minimal polynomials of
// cosh_c and sinh_c and also x^4 + 1.
var prime = 89;
var prime2 = prime*prime;
var prime3 = prime2*prime;

var maxsize = 2*prime3;

var group_size = prime*(prime-1)*(prime+1)/2;

// The matrix [[a,b],[c,d]] of PGL(F_q) is represented as the integer
// a*q^3 + b*q^2 + c*q + d with normalization being such that the
// first nonzero coefficient is one (so maximal value = 2*q^3).

// Each maze cell is represented by four different elements of
// PSL_2(F_p) (one for each wall of the cell), and each maze wall by
// two different elements (one for each side of the wall, i.e.,
// adjacent cell).

var pgl_fp_idn = 704970;  // Identity matrix
var pgl_fp_rot1 = 705003;  // Hyperbolic rotation (R^4 = 1)
var pgl_fp_rot2 = 705057;  // R^2
var pgl_fp_rot3 = 705024;  // R^3
var pgl_fp_trn = 985320;  // Hyperbolic translation ((R*T)^5 = 1)
var pgl_fp_tflip = 1135906;  // T*R^2

var fp_inverses = new Array(prime);
function compute_fp_inverses() {
    "use strict";
    // Do a stupid quadratic search because prime is small and that
    // is easier to write. :-/
    for ( var i=1 ; i<prime ; i++ ) {
        for ( var j=1 ; j<prime ; j++ ) {
            if ( (i*j)%prime == 1 )
                fp_inverses[i] = j;
        }
    }
}
compute_fp_inverses();

var fp_square_roots = new Array(prime);
function compute_fp_square_roots() {
    "use strict";
    // Compute square roots of the elements of the prime field.
    for ( var i=0 ; i<prime/2 ; i++ ) {
        var j = (i*i)%prime;
        fp_square_roots[j] = i;
    }
}
compute_fp_square_roots();

function moebius_product (m1, m2, m) {
    "use strict";
    // Compute the product of two Möbius transformations.  Store the
    // result in m, or allocate a new value if no m is provided.
    if ( typeof(m) == "undefined" )
        m = new Array(4);
    m[0] = (m1[0]*m2[0] - m1[1]*m2[1] + m1[2]*m2[2] + m1[3]*m2[3]);
    m[1] = (m1[0]*m2[1] + m1[1]*m2[0] - m1[2]*m2[3] + m1[3]*m2[2]);
    m[2] = (m1[0]*m2[2] - m1[1]*m2[3] + m1[2]*m2[0] + m1[3]*m2[1]);
    m[3] = (m1[0]*m2[3] + m1[1]*m2[2] - m1[2]*m2[1] + m1[3]*m2[0]);
    return m;
}

function moebius_inverse (m) {
    "use strict";
    // Compute the inverse of a Möbius transformation.
    return [m[0], -m[1], -m[2], -m[3]];
}

function moebius_apply (m, z) {
    "use strict";
    // Apply a Möbius transformation to a complex z.
    var numer0 = m[0]*z[0] - m[1]*z[1] + m[2];
    var numer1 = m[0]*z[1] + m[1]*z[0] + m[3];
    var denom0 = m[2]*z[0] + m[3]*z[1] + m[0];
    var denom1 = m[2]*z[1] - m[3]*z[0] - m[1];
    var denom_norm = denom0*denom0 + denom1*denom1;
    return [(numer0*denom0+numer1*denom1)/denom_norm,
            (-numer0*denom1+numer1*denom0)/denom_norm];
}

function moebius_diff (m, z) {
    "use strict";
    // Compute the differential of a Möbius transformation at z.
    var denom0 = m[2]*z[0] + m[3]*z[1] + m[0];
    var denom1 = m[2]*z[1] - m[3]*z[0] - m[1];
    var denom_norm = denom0*denom0 + denom1*denom1;
    return [(denom0*denom0-denom1*denom1)/(denom_norm*denom_norm),
            -(2*denom0*denom1)/(denom_norm*denom_norm)];
}

function moebius_renormalize (m) {
    "use strict";
    // Enforce the determinant of m to be 1 (for numeric stability).
    var det = m[0]*m[0] + m[1]*m[1] - m[2]*m[2] - m[3]*m[3];
    var nr = 1/Math.sqrt(det);
    for ( var i=0 ; i<4 ; i++ )
        m[i] *= nr;
}

function psl_fp_valid (m) {
    "use strict";
    // Check whether m is a valid representation of an element of
    // PSL_2(F_p).
    m = m|0;
    var ma = (m/prime3)|0;
    var mb = ((m/prime2)|0)%prime;
    var mc = ((m/prime)|0)%prime;
    var md = m%prime;
    if ( ! ((ma==1)||((ma==0)&&(mb==1))) )
        return false;
    var det = ((ma*md)%prime + prime - (mb*mc)%prime) % prime;
    return (det != 0) && fp_square_roots[det];
}

function pgl_fp_product (m1, m2) {
    "use strict";
    // Compute the product of two elements of PGL_2(F_p).
    m1 = m1|0;  m2 = m2|0;
    var m1a = (m1/prime3)|0;
    var m1b = ((m1/prime2)|0)%prime;
    var m1c = ((m1/prime)|0)%prime;
    var m1d = m1%prime;
    var m2a = (m2/prime3)|0;
    var m2b = ((m2/prime2)|0)%prime;
    var m2c = ((m2/prime)|0)%prime;
    var m2d = m2%prime;
    var ma = (m1a*m2a + m1b*m2c) % prime;
    var mb = (m1a*m2b + m1b*m2d) % prime;
    var mc = (m1c*m2a + m1d*m2c) % prime;
    var md = (m1c*m2b + m1d*m2d) % prime;
    if ( ma != 0 ) {
        mb = (mb * fp_inverses[ma]) % prime;
        mc = (mc * fp_inverses[ma]) % prime;
        md = (md * fp_inverses[ma]) % prime;
        ma = 1;
    } else if ( mb != 0 ) {
        mc = (mc * fp_inverses[mb]) % prime;
        md = (md * fp_inverses[mb]) % prime;
        mb = 1;
    } else
        throw new Error("This is impossible");
    return ma*prime3 + mb*prime2 + mc*prime + md;
}

function pgl_fp_inverse (m0) {
    "use strict";
    // Compute the inverse of an element of PGL_2(F_p).
    m0 = m0|0;
    var m0a = (m0/prime3)|0;
    var m0b = ((m0/prime2)|0)%prime;
    var m0c = ((m0/prime)|0)%prime;
    var m0d = m0%prime;
    var ma = m0d;
    var mb = (prime - m0b) % prime;
    var mc = (prime - m0c) % prime;
    var md = m0a;
    if ( ma != 0 ) {
        mb = (mb * fp_inverses[ma]) % prime;
        mc = (mc * fp_inverses[ma]) % prime;
        md = (md * fp_inverses[ma]) % prime;
        ma = 1;
    } else if ( mb != 0 ) {
        mc = (mc * fp_inverses[mb]) % prime;
        md = (md * fp_inverses[mb]) % prime;
        mb = 1;
    } else
        throw new Error("This is impossible");
    return ma*prime3 + mb*prime2 + mc*prime + md;
}

// For more efficiency, we cache the products of g times R (rot1) and
// g times T (trn) for g in PSL_2(F_p).
var cache_rot1;
var cache_trn;
if ( typeof(Int32Array) == "function" ) {
    cache_rot1 = new Int32Array(maxsize);
    cache_trn = new Int32Array(maxsize);
} else {
    cache_rot1 = new Array(maxsize);
    cache_trn = new Array(maxsize);
}

function fast_rot1(i) {
    "use strict";
    i = i|0;
    if ( cache_rot1[i] )
        return cache_rot1[i];
    else
        return cache_rot1[i] = pgl_fp_product(i, pgl_fp_rot1);
}

function fast_rot2(i) {
    "use strict";
    i = i|0;
    return fast_rot1(fast_rot1(i));
}

function fast_rot3(i) {
    "use strict";
    i = i|0;
    return fast_rot1(fast_rot1(fast_rot1(i)));
}

function fast_trn(i) {
    "use strict";
    i = i|0;
    if ( cache_trn[i] )
        return cache_trn[i];
    else
        return cache_trn[i] = pgl_fp_product(i, pgl_fp_trn);
}

// List of items to draw (items are both edges and circles/cells).
// Each item is a 6-element list:
// [0] is the Möbius transformation used to draw the item.
// [1] is the corresponding element of PGL_2(F_p).
// [2] is unused.
// [3] is a boolean indicating whether this should be used to draw a
//     square (false means that the same cell is not canonical,
//     so it is represented by some other of the four products of this
//     element by some power of R).
// [4] is a boolean indicating whether this should also be drawn in
//     the Beltrami-Klein model.

var drawn_parts = [];
var drawn_hash = {};

function compute_drawn_parts () {
    "use strict";
    var queue = [[moebius_idn, pgl_fp_idn]];
    while ( queue.length > 0 ) {
        var p = queue.shift();
        var cur = p[0];
        var cur_fp = p[1];
        if ( ( typeof(drawn_hash[cur_fp]) == "undefined" ) && ( cur[0]*cur[0]+cur[1]*cur[1] < 50 ) ) {
            var cur_rot1 = moebius_product(cur, moebius_rot1);
            var cur_rot1_fp = fast_rot1(cur_fp);
            var cur_rot3 = moebius_product(cur, moebius_rot3);
            var cur_rot3_fp = fast_rot3(cur_fp);
            var cur_trn = moebius_product(cur, moebius_trn);
            var cur_trn_fp = fast_trn(cur_fp);
            var cur_rot2_fp = fast_rot1(cur_rot1_fp);
            p.push(undefined);
            // Check whether this is the first part for this square:
            p.push( typeof(drawn_hash[cur_rot1_fp]) == "undefined"
                    && typeof(drawn_hash[cur_rot3_fp]) == "undefined"
                    && typeof(drawn_hash[cur_rot2_fp]) == "undefined" );
            p.push(cur[0]*cur[0]+cur[1]*cur[1] < 15);
            // Register this drawn part.
            drawn_hash[cur_fp] = drawn_parts.length;
            drawn_parts.push(p);
            queue.push([cur_rot1, cur_rot1_fp], [cur_rot3, cur_rot3_fp], [cur_trn, cur_trn_fp]);
        }
    }
}
compute_drawn_parts();

var distances = new Array(maxsize);  // Distance (in squares) from the identity
function compute_distances () {
    "use strict";
    // Fill in the distances table.
    var queue = new Array(maxsize);
    var qlen, q;
    distances[pgl_fp_idn] = 0;
    distances[pgl_fp_rot1] = 0;
    distances[pgl_fp_rot2] = 0;
    distances[pgl_fp_rot3] = 0;
    qlen = 0;
    queue[qlen++] = pgl_fp_idn;
    queue[qlen++] = pgl_fp_rot1;
    queue[qlen++] = pgl_fp_rot2;
    queue[qlen++] = pgl_fp_rot3;
    q = 0;
    while ( q < qlen ) {
        // Remove the first item from the queue.
        var pos = queue[q++];
        var tpos = fast_trn(pos);
        if ( typeof(distances[tpos]) != "undefined" ) {
            if ( distances[tpos] > distances[pos]+1 )
                throw new Error("This is impossible");
        } else {
            distances[tpos] = distances[pos]+1;
            distances[fast_rot1(tpos)] = distances[pos]+1;
            distances[fast_rot2(tpos)] = distances[pos]+1;
            distances[fast_rot3(tpos)] = distances[pos]+1;
            queue[qlen++] = tpos;
            queue[qlen++] = fast_rot1(tpos);
            queue[qlen++] = fast_rot3(tpos);
        }
    }
}
// compute_distances();  // Will do this lazily in track_as_moebius()

// A subgroup of PGL_2(F_p) isomorphic to the symmetric group on 4 objects:
var subgroup = [704970, 15753, 982149, 1405077,
                974427, 1148511, 715971, 8010,
                717819, 1406967, 705057, 1140747,
                1402107, 720723, 705003, 1143738,
                12816, 705024, 977310, 1409937,
                1145520, 979266, 713067, 10947];

var bootcols = [[139,69,19], [255,223,0], [255,165,0], [255,69,0],
                [0,128,0], [0,255,0], [0,255,255], [0,0,255],
                [75,0,130], [238,130,238], [255,20,147], [255,105,180],
                [255,255,255], [169,169,169], [128,128,128], [105,105,105],
                [255,228,196], [255,218,185], [255,222,173], [255,250,205],
                [255,255,224], [240,230,140], [255,239,213], [255,245,238]];

var orbcols = [[139,69,19], [255,223,0], [255,165,0], [255,69,0],
               [0,128,0], [0,255,0], [0,255,255], [0,0,255],
               [75,0,130], [238,130,238], [255,20,147], [255,105,180],
               [255,255,255], [169,169,169], [128,128,128], [105,105,105],
               [255,228,196], [255,218,185], [255,222,173], [255,250,205],
               [255,255,224], [240,230,140], [255,239,213], [255,245,238]];

var orbnames = ["Poop", "Pee", "Fart", "Burp",
                "Vomit", "Snot", "Booger", "Puke",
                "Diarrhea", "Pus", "Phlegm", "Spit",
                "Earwax", "Buttcrack", "Armpit", "Toe Jam",
                "Dingleberry", "Skidmark", "Crotch", "Sweat",
                "Gas", "Stink", "Stench", "Crud"];

var definitions = ["Strength: force of character",
                   "Valor: boldness in regard to danger",
                   "Courage: confidence in overcoming fear",
                   "Determination: firmness of purpose and resolution",
                   "Will: purposefulness, intent, volition",
                   "Agreement: harmony of opinion, understanding",
                   "Intelligence: capacity of thought and reason",
                   "Honesty: truthfulness, good faith, lack of malice",
                   "Knowledge: intellectual understanding of truth and information",
                   "Wisdom: good judgment and ability to discern the truth",
                   "Justice: ideal of fairness and impartiality in judgment",
                   "Honor: state of being morally upright",
                   "Benevolence: disposition to do good",
                   "Compassion: wish to relieve others of suffering",
                   "Tenderness: concern for the feelings and welfare of others",
                   "Clemency: disposition to show mercy",
                   "Forgiveness: readiness to forgive, pardon",
                   "Compromise: ability to make concessions to settle differences",
                   "Humility: modesty, lack of pride or arrogance",
                   "Patience: perseverance in pursuit, willingness to endure",
                   "Prudence: caution and discretion in one's actions",
                   "Temperance: moderation and restraint",
                   "Tolerance: acceptance of the beliefs and practices of others",
                   "Kindness: gentleness and charitable interest in others"];

// Table of the world
// Each item is a list:
// [0] is the color of the cell (a 3-element list).
// [1] is the index of the realm it belongs to.
// [2] is true if there is an orb there (number is given by [1]).
// [3] if defined is boolean indicating whether there is a bread crumb here.
// [4] if defined gives the number of the beacon dropped here.

// NOTE: All except [3] should be identical upon postmultiplication of
// the index by pgl_fp_rot1, pgl_fp_rot2, pgl_fp_rot3.  The
// corresponding cells might even be aliased: code should be prepared
// to handle that possibility or not.

var world_table;

function generate_world () {
    "use strict";
    // Generate the world.
    // The orbs are placed on a double coset lft * H * rgt of a
    // subgroup H defined above.
    var rgt, lft;
    do {
        do
            rgt = Math.floor(Math.random()*maxsize);
        while ( ! psl_fp_valid(rgt) );
        // Make sure two orbs are never too close one to another.
        var redo = false;
        for ( var i=0 ; i<subgroup.length ; i++ ) {
            var mvt = pgl_fp_product(pgl_fp_inverse(rgt),
                                     pgl_fp_product(subgroup[i], rgt));
            if ( mvt != pgl_fp_idn && typeof(drawn_hash[mvt]) != "undefined" ) {
                // console.log("rgt="+rgt+" is not appropriate because it conjugates "+subgroup[i]+" to "+mvt+" which is too close");
                redo = true;
                break;
            }
        }
    } while ( redo );
    do {
        do
            lft = Math.floor(Math.random()*maxsize);
        while ( ! psl_fp_valid(lft) );
        var redo = true;
        // Make sure some orb is not too far from the origin.
        for ( var i=0 ; i<subgroup.length ; i++ ) {
            var mvt = pgl_fp_product(lft, pgl_fp_product(subgroup[i], rgt));
            if ( typeof(drawn_hash[mvt]) != "undefined" ) {
                // console.log("lft="+lft+" might be appropriate because it moves "+subgroup[i]+" to "+mvt+" which is not too far away");
                redo = false;
                break;
            }
        }
        if ( redo )
            continue;
        // Make sure no orb is too close to the origin.
        for ( var i=0 ; i<subgroup.length ; i++ ) {
            var mvt = pgl_fp_product(lft, pgl_fp_product(subgroup[i], rgt));
            if ( typeof(drawn_hash[mvt]) != "undefined" && drawn_parts[drawn_hash[mvt]][4] ) {
                // console.log("lft="+lft+" is not appropriate because it moves "+subgroup[i]+" to "+mvt+" which is too close");
                redo = true;
                break;
            }
        }
    } while ( redo );
    // We fill the world with as many queues as realms, each
    // consisting of those squares/directions in which the realm might grow.
    world_table = new Array(maxsize);
    var filled = [];  var totqcnt = 0;
    var queue = [];
    var qlen = [];  var q = [];  // End and start of queues.
    for ( var i=0 ; i<subgroup.length ; i++ ) {
        // Place the orbs first.
        qlen[i] = 0;
        q[i] = 0;
        var pos;
        pos = pgl_fp_product(lft, pgl_fp_product(subgroup[i], rgt));
        var cell = [bootcols[i], i, true];
        world_table[pos] = cell;
        world_table[fast_rot1(pos)] = cell;
        world_table[fast_rot2(pos)] = cell;
        world_table[fast_rot3(pos)] = cell;
        filled[i] = 1;
        queue[i] = [];
        queue[i][qlen[i]++] = pos;
        queue[i][qlen[i]++] = fast_rot1(pos);
        queue[i][qlen[i]++] = fast_rot2(pos);
        queue[i][qlen[i]++] = fast_rot3(pos);
        totqcnt += 4;
    }
    // Now try to expand each realm in turn until all queues are empty.
    var i = 0;
    while ( totqcnt > 0 ) {
        if ( q[i] < qlen[i] ) {
            // Remove a random element from the queue (for that realm).
            var qrnd = q[i] + Math.floor(Math.random()*(qlen[i]-q[i]));
            var pos = queue[i][qrnd];
            queue[i][qrnd] = queue[i][q[i]++];
            totqcnt--;
            var tpos = fast_trn(pos);
            if ( typeof(world_table[tpos]) == "undefined" ) {
                // We can grow in that direction: do so.
                var cell = world_table[pos];
                var col = cell[0];
                if ( Math.random() < 0.4 ) {  // Slight color change.
                    col = col.slice();
                    for ( var ii=0 ; ii<3 ; ii++ ) {
                        col[ii] = col[ii] + Math.floor(Math.random()*21) - 10;
                        if ( col[ii] < 0 )
                            col[ii] = 0;
                        if ( col[ii] > 255 )
                            col[ii] = 255;
                    }
                }
                var tcell = [col, cell[1], false];
                world_table[tpos] = tcell;
                world_table[fast_rot1(tpos)] = tcell;
                world_table[fast_rot2(tpos)] = tcell;
                world_table[fast_rot3(tpos)] = tcell;
                filled[i]++;
                queue[i][qlen[i]++] = tpos;
                queue[i][qlen[i]++] = fast_rot1(tpos);
                queue[i][qlen[i]++] = fast_rot3(tpos);
                totqcnt += 3;
            }
        }
        i = (i+1) % subgroup.length;
    }
    // console.log("Size of regions: "+filled);
}
generate_world();

// Canvas and canvas drawing context
var canvas;
var ctx;

function draw_hyperbolic_square_poincare (m, col) {
    "use strict";
    // We approximate a hyperbolic edge by a Bézier curve (rather than
    // an arc of circle).
    ctx.fillStyle = "rgb("+col[0]+","+col[1]+","+col[2]+")";
    ctx.beginPath();
    for ( var i=0 ; i<4 ; i++ ) {
        var mm = moebius_product (m, moebius_product(moebius_rottab[3-i], moebius_half_trn));
        var p0 = moebius_apply (mm, [0, tanh_half_b]);
        var p1 = moebius_apply (mm, [0, -tanh_half_b]);
        var pd0 = moebius_diff (mm, [0, tanh_half_b]);
        var pd1 = moebius_diff (mm, [0, -tanh_half_b]);
        if ( i==0 )
            ctx.moveTo(p0[0], p0[1]);
        ctx.bezierCurveTo(p0[0]+2*pd0[1]*tanh_half_b/3,
                          p0[1]-2*pd0[0]*tanh_half_b/3,
                          p1[0]-2*pd1[1]*tanh_half_b/3,
                          p1[1]+2*pd1[0]*tanh_half_b/3,
                          p1[0], p1[1]);
    }
    ctx.closePath();
    ctx.fill();
}

function draw_hyperbolic_circle_poincare (m, col, orad) {
    "use strict";
    // Since the circle is centered at the origin before
    // transformation, we can afford to use the exact formulæ for the
    // transform of a circle by a Möbius transformation.
    var cen0, cen1, radius, vradius;
    function transform_circle (oradius) {
        "use strict";
        // (NB: oradius is tanh(r/2) where r is the true hyperbolic radius.)
        var denom = m[0]*m[0] + m[1]*m[1] - (m[2]*m[2] + m[3]*m[3])*oradius*oradius;
        cen0 = (m[2]*m[0] - m[3]*m[1] - (m[0]*m[2] - m[1]*m[3])*oradius*oradius) / denom;
        cen1 = (m[3]*m[0] + m[2]*m[1] - (m[1]*m[2] + m[0]*m[3])*oradius*oradius) / denom;
        radius = oradius / denom;
        vradius = (m[0]*m[0] + m[1]*m[1] + (m[2]*m[2] + m[3]*m[3])*oradius*oradius)/(denom*denom);
    }
    ctx.fillStyle = "rgb("+col[0]+","+col[1]+","+col[2]+")";
    ctx.beginPath();
    transform_circle(orad);
    ctx.arc(cen0, cen1, radius, 0, 2*Math.PI, false);
    ctx.fill();
}

function poincare_to_bk (p) {
    "use strict";
    // Convert from Poincaré to Beltrami-Klein coordinates.
    var t = 1 + p[0]*p[0] + p[1]*p[1];
    return [2*p[0]/t, 2*p[1]/t];
}

function poincare_to_bk_diff (p, dp) {
    "use strict";
    // Differential of the above
    var t = 1 + p[0]*p[0] + p[1]*p[1];
    var v = p[0]*dp[0] + p[1]*dp[1];
    return [2*dp[0]/t - 2*v*p[0]/(t*t), 2*dp[1]/t - 2*v*p[1]/(t*t)];
}

function draw_hyperbolic_square_bk (m, col) {
    "use strict";
    // Straight lines become straight lines in the Beltrami-Klein model.
    ctx.fillStyle = "rgb("+col[0]+","+col[1]+","+col[2]+")";
    ctx.beginPath();
    for ( var i=0 ; i<4 ; i++ ) {
        var mm = moebius_product (m, moebius_product(moebius_rottab[3-i], moebius_half_trn));
        var bk0 = poincare_to_bk (moebius_apply (mm, [0, tanh_half_b]));
        var bk1 = poincare_to_bk (moebius_apply (mm, [0, -tanh_half_b]));
        if ( i==0 )
            ctx.moveTo(bk0[0], bk0[1]);
        ctx.lineTo(bk1[0], bk1[1]);
    }
    ctx.closePath();
    ctx.fill();
}

function draw_hyperbolic_circle_bk (m, col, orad) {
    "use strict";
    var bkcen0, bkcen1, bkangle, bkmaj, bkmin;
    function transform_circle (oradius) {
        "use strict";
        var denom = m[0]*m[0] + m[1]*m[1] - (m[2]*m[2] + m[3]*m[3])*oradius*oradius;
        var pcen0 = (m[2]*m[0] - m[3]*m[1] - (m[0]*m[2] - m[1]*m[3])*oradius*oradius) / denom;
        var pcen1 = (m[3]*m[0] + m[2]*m[1] - (m[1]*m[2] + m[0]*m[3])*oradius*oradius) / denom;
        var pradius = oradius / denom;
        var pcdst = Math.sqrt(pcen0*pcen0 + pcen1*pcen1);
        var up0 = pcen0/pcdst;
        var up1 = pcen1/pcdst;
        if ( pcdst < 1.e-9 ) {
            up0 = 1;  up1 = 0;
        }
        var bkfar = poincare_to_bk([pcen0 + pradius*up0, pcen1 + pradius*up1]);
        var bknear = poincare_to_bk([pcen0 - pradius*up0, pcen1 - pradius*up1]);
        var bkcen = [(bkfar[0]+bknear[0])/2, (bkfar[1]+bknear[1])/2];
        bkcen0 = bkcen[0];  bkcen1 = bkcen[1];  // Center of the ellipse
        bkangle = Math.atan2(pcen1, pcen0);  // Angle of minor axis
        // Semi-minor axis:
        bkmin = Math.sqrt((bkfar[0]-bkcen[0])*(bkfar[0]-bkcen[0])
                          + (bkfar[1]-bkcen[1])*(bkfar[1]-bkcen[1]));
        var bkaux = poincare_to_bk([pcen0 - pradius*up1, pcen1 + pradius*up0]);
        var dpar = Math.abs((bkaux[0]-bkcen[0])*up0 + (bkaux[1]-bkcen[1])*up1);
        var dort = Math.abs((bkaux[0]-bkcen[0])*up1 - (bkaux[1]-bkcen[1])*up0);
        // Semi-major axis:
        bkmaj = dort/Math.sqrt(1-(dpar/bkmin)*(dpar/bkmin));
    }
    ctx.fillStyle = "rgb("+col[0]+","+col[1]+","+col[2]+")";
    ctx.beginPath();
    transform_circle(orad);
    ctx.save();  ctx.translate(bkcen0, bkcen1);  ctx.rotate(bkangle);
    ctx.scale(bkmin, bkmaj);  ctx.arc(0, 0, 1, 0, 2*Math.PI, false);
    ctx.fill();  ctx.restore();
}

function track_as_moebius(tgt) {
    "use strict";
    var elt = pgl_fp_product(pgl_fp_inverse(tgt), current_fp);
    var trsf = current;
    if ( typeof(distances[pgl_fp_idn]) == "undefined" )
        compute_distances();
    while ( distances[elt] > 0 ) {
        for ( var k=0 ; k<4 ; k++ ) {
            if ( distances[fast_trn(elt)] < distances[elt] ) {
                elt = fast_trn(elt);
                trsf = moebius_product(trsf, moebius_trn);
                break;
            }
            elt = fast_rot1(elt);
            trsf = moebius_product(trsf, moebius_rot1);
        }
        if ( k >= 4 )
            throw new Error("This is impossible");
    }
    return trsf;
}

var using_bk;  // True if using Beltrami-Klein projection
var draw_hyperbolic_square;  // Either draw_hyperbolic_square_poincare or _bk
var draw_hyperbolic_circle;  // Either draw_hyperbolic_circle_poincare or _bk

canvas = document.getElementById("canvas");
if ( typeof(canvas.getContext) != "function" ) {
    alert("Your browser does not support the HTML5 <canvas> element.\n"
          + "This page will not function.");
    throw new Error("Canvas unsupported");
}
ctx = canvas.getContext("2d");
ctx.lineCap = "round";
ctx.lineJoin = "round";
var scale = Math.min(canvas.width/2, canvas.height/2) - 10;

// The user's current position: as a Möbius transformation (which gets
// regularly reduced by the lattice group), as an element of PSL_2(F_q).
var current = moebius_idn;
var current_fp = pgl_fp_idn;

function write_string_in_id (id, str) {
    "use strict";
    // Write a string in a DOM node.
    var node;
    node = document.getElementById(id);
    while ( node.firstChild )
        node.removeChild(node.firstChild);
    node.appendChild(document.createTextNode(str));
}

var orbs_found = [];

function did_move() {
    "use strict";
    // Called after the user moved to a different square
    var k = world_table[current_fp][1];
    if ( world_table[current_fp][2] ) {
        if ( orbs_found.length == 0 ) {
            document.getElementById("orbs").appendChild(
                document.createTextNode("Orbs found so far ("));
            var orbcntelt = document.createElementNS("http://www.w3.org/1999/xhtml", "span");
            orbcntelt.id = "orbcnt";
            document.getElementById("orbs").appendChild(orbcntelt);
            document.getElementById("orbs").appendChild(
                document.createTextNode("):"));
            document.getElementById("orbs").appendChild(
                document.createElementNS("http://www.w3.org/1999/xhtml", "br"));
            var orblstelt = document.createElementNS("http://www.w3.org/1999/xhtml", "span");
            orblstelt.id = "orblst";
            document.getElementById("orbs").appendChild(orblstelt);
        }
        orbs_found.push(k);
        write_string_in_id("orbcnt", orbs_found.length);
        var tinycan = document.createElementNS("http://www.w3.org/1999/xhtml",
                                               "canvas");
        tinycan.width = 64;
        tinycan.height = 64;
        document.getElementById("orblst").appendChild(tinycan);
        var ctx = tinycan.getContext("2d");
        ctx.fillStyle = "rgb(128,128,128)";
        ctx.fillRect(0,0,tinycan.width,tinycan.height);
        ctx.fillStyle = k<12 ? "rgb(0,0,0)" : "rgb(255,255,255)";
        ctx.beginPath();
        ctx.arc(tinycan.width/2, tinycan.height/2, 30, 0, 2*Math.PI, false);
        ctx.fill();
        ctx.fillStyle = "rgb("+orbcols[k][0]+","+orbcols[k][1]+","+orbcols[k][2]+")";
        ctx.beginPath();
        ctx.arc(tinycan.width/2, tinycan.height/2, 24, 0, 2*Math.PI, false);
        ctx.fill();
        tinycan.title = "The orb of "+orbnames[k];
        tinycan.addEventListener("click", function(e) {
            "use strict";
            alert(definitions[k]);
            e.preventDefault();
        });
        write_string_in_id("message", "You found the orb of "+orbnames[k]+"!");
        if ( orbs_found.length == subgroup.length )
            write_string_in_id("goal", "You found all the orbs!  Congratulations, you won!");
        world_table[current_fp][2] = false;
        // The following should be redundant because of aliasing, but no matter:
        world_table[fast_rot1(current_fp)][2] = false;
        world_table[fast_rot2(current_fp)][2] = false;
        world_table[fast_rot3(current_fp)][2] = false;
    } else
        write_string_in_id("message", "You are in the realm of "+orbnames[k]
                           +(orbs_found.indexOf(k)>=0 ? " (you have its orb)" : "")+".");
}

var do_bread_crumbs = false;
var have_bread_crumbs = false;

var beaconscols = [[[64,0,0],[128,0,0],[255,0,0]],
                   [[0,64,0],[0,128,0],[0,255,0]],
                   [[0,0,64],[0,0,128],[0,0,255]]];

var beacons = [];

function draw_all() {
    "use strict";
    // Draw the canvas.
    ctx.fillStyle = "rgb(255,255,255)";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.save();
    ctx.translate(canvas.width/2, canvas.height/2);
    ctx.scale(scale, scale);
    ctx.rotate(-Math.PI/2);
    ctx.fillStyle = "rgb(128,128,128)";
    ctx.beginPath();
    ctx.arc(0, 0, 1, 0, 2*Math.PI, false);
    ctx.fill();
    // Draw squares.
    var trans = new Array(4);
    var trans_fp;
    for ( var i=0 ; i<drawn_parts.length ; i++ ) {
        if ( ( have_bread_crumbs || drawn_parts[i][3] )
             && ( drawn_parts[i][4] || ! using_bk ) ) {
            trans_fp = pgl_fp_product(current_fp, drawn_parts[i][1]);
            var k = world_table[trans_fp][1];
            if ( drawn_parts[i][3] || world_table[trans_fp][3] )
                moebius_product(current, drawn_parts[i][0], trans);
            if ( drawn_parts[i][3] )
                // The cell itself
                draw_hyperbolic_square(trans, world_table[trans_fp][0]);
            if ( world_table[trans_fp][3] )
                // Bread crumb
                draw_hyperbolic_circle(moebius_product(trans, breadcrumbs_trans),
                                       k<12 ? [112,112,112] : [144,144,144], 0.02);
            if ( drawn_parts[i][3] && typeof(world_table[trans_fp][4]) != "undefined" ) {
                // Beacon
                var iii = world_table[trans_fp][4];
                draw_hyperbolic_circle(trans, beaconscols[iii][0], 0.09);
                draw_hyperbolic_circle(trans, beaconscols[iii][1], 0.06);
                draw_hyperbolic_circle(trans, beaconscols[iii][2], 0.03);
            }
            if ( drawn_parts[i][3] && world_table[trans_fp][2] ) {
                // Orb
                draw_hyperbolic_circle(trans, k<12 ? [0,0,0] : [255,255,255], 0.1);
                draw_hyperbolic_circle(trans, orbcols[k], 0.08);
            }
        }
    }
    // Draw beacon tracking lines.
    for ( var i=0 ; i<beaconscols.length ; i++ )
        if ( typeof(beacons[i]) != "undefined" ) {
            var trsf = track_as_moebius(beacons[i]);
            var p = moebius_apply(trsf, [0, 0]);
            var nrm = Math.sqrt(p[0]*p[0] + p[1]*p[1]);
            if ( nrm >= 0.1 ) {
                p[0] /= nrm;  p[1] /= nrm;
                ctx.strokeStyle = "rgb("+beaconscols[i][1][0]+","+beaconscols[i][1][1]+","+beaconscols[i][1][2]+")";
                ctx.beginPath();
                ctx.lineWidth = .008;
                ctx.moveTo(p[0], p[1]);
                ctx.lineTo(p[0]*1.03, p[1]*1.03);
                ctx.stroke();
            }
        }
    // Draw center cross.
    ctx.restore();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgb(0,0,0)";
    ctx.beginPath();
    ctx.moveTo(canvas.width/2-3, canvas.height/2-3);
    ctx.lineTo(canvas.width/2+3, canvas.height/2+3);
    ctx.moveTo(canvas.width/2-3, canvas.height/2+3);
    ctx.lineTo(canvas.width/2+3, canvas.height/2-3);
    ctx.stroke();
}

var please_wait_node = document.getElementById("please-wait");
please_wait_node.parentNode.removeChild(please_wait_node);

function beacon_action(inum, btn) {
    "use strict";
    // Drop or recall beacon.
    if ( typeof(beacons[inum]) == "undefined" ) {
        if ( typeof(world_table[current_fp][4]) != "undefined" )
            return;
        beacons[inum] = current_fp;
        // The following should work whether aliased or not:
        world_table[current_fp][4] = inum;
        world_table[fast_rot1(current_fp)][4] = inum;
        world_table[fast_rot2(current_fp)][4] = inum;
        world_table[fast_rot3(current_fp)][4] = inum;
        btn.value = "recall";
        draw_all();
    } else {
        var pos = beacons[inum];
        beacons[inum] = undefined;
        // The following should work whether aliased or not:
        world_table[pos][4] = undefined;
        world_table[fast_rot1(pos)][4] = undefined;
        world_table[fast_rot2(pos)][4] = undefined;
        world_table[fast_rot3(pos)][4] = undefined;
        btn.value = "drop";
        draw_all();
    }
}

var beacons_list = document.getElementById("beacons-list");
function fill_beacons_list() {
    "use strict";
    for ( var i=0 ; i<beaconscols.length ; i++ ) {
        var btn = document.createElementNS("http://www.w3.org/1999/xhtml",
                                           "input");
        btn.type = "button";
        btn.style.color = "rgb("+beaconscols[i][1][0]+","+beaconscols[i][1][1]+","+beaconscols[i][1][2]+")";
        btn.value = "drop";
        btn.id = "beacon-button-"+i;
        (function(icopy,btncopy) {
            btn.addEventListener("click", function(e) {
                "use strict";
                beacon_action(icopy, btncopy);
		btncopy.blur();
                e.preventDefault();
            });
        })(i,btn);
        if ( i > 0 )
            beacons_list.appendChild(document.createTextNode(" "));
        beacons_list.appendChild(btn);
    }
}
fill_beacons_list();

var projection_sel = document.getElementById("projection-sel");
function select_projection() {
    "use strict";
    if ( projection_sel.value == 0 ) {
        using_bk = false;
        draw_hyperbolic_square = draw_hyperbolic_square_poincare;
        draw_hyperbolic_circle = draw_hyperbolic_circle_poincare;
    } else {
        using_bk = true;
        draw_hyperbolic_square = draw_hyperbolic_square_bk;
        draw_hyperbolic_circle = draw_hyperbolic_circle_bk;
    }
}

projection_sel.addEventListener("change", function(e) {
    select_projection ();
    draw_all ();
    projection_sel.blur();
    e.preventDefault();
});

select_projection();
did_move();
write_string_in_id("goal", "Your goal is to collect all "+subgroup.length+" orbs (one per realm).");
draw_all();

function put_bread_crumb(pos) {
    "use strict";
    if ( typeof(world_table[pos][3]) == "undefined" )
        world_table[pos] = world_table[pos].slice();  // Unalias!
    world_table[pos][3] = true;
    have_bread_crumbs = true;
}

var breadcrumbs_sel = document.getElementById("breadcrumbs-sel");
breadcrumbs_sel.addEventListener("change", function(e) {
    "use strict";
    if ( breadcrumbs_sel.value == 0 ) {
        do_bread_crumbs = false;
    } else {
        do_bread_crumbs = true;
        put_bread_crumb (current_fp);
        draw_all();
    }
    breadcrumbs_sel.blur();
    e.preventDefault();
});

var breadcrumbs_erase = document.getElementById("breadcrumbs-erase");
breadcrumbs_erase.addEventListener("click", function(e) {
    "use strict";
    for ( var i=0 ; i<maxsize ; i++ )
        if ( typeof(world_table[i]) == "object"
             && world_table[i][3] )
            world_table[i][3] = false;
    have_bread_crumbs = false;
    draw_all();
    e.preventDefault();
});

function rotate(theta) {
    // Rotate by theta radians.
    current = moebius_product([Math.cos(theta/2), Math.sin(theta/2), 0, 0],
                              current);
    moebius_renormalize (current);
    draw_all();
}

if ( typeof(Math.cosh) == "function" ) {
    // Good boy!
} else {
    Math.cosh = function(t) { return (Math.exp(t)+Math.exp(-t))/2; }
    Math.sinh = function(t) { return (Math.exp(t)-Math.exp(-t))/2; }
}

function move(dst, diru, dirv) {
    "use strict";
    // Move by dst (in hyperbolic distance) in direction (diru,dirv).
    var cosh_half_dst = Math.cosh(dst/2);
    var sinh_half_dst = Math.sinh(dst/2);
    var dirnorm = Math.sqrt(diru*diru + dirv*dirv);
    diru /= dirnorm;  dirv /= dirnorm;
    var movement =
        [cosh_half_dst, 0, -sinh_half_dst*diru, sinh_half_dst*dirv];
    var candidate = moebius_product(movement, current);
    var candidate_fp = current_fp;
    var p = moebius_apply (moebius_inverse(candidate), [0,0]);
    var changed_square = false;
    while ( 1 ) {
        // Find the nearest edge.
        if ( p[1]>p[0] && p[1]<-p[0] ) {
            candidate = moebius_product(candidate, moebius_rot2);
            p = moebius_apply(moebius_rot2, p);
            candidate_fp = pgl_fp_product(candidate_fp, pgl_fp_rot2);
        } else if ( p[1]>p[0] ) {
            candidate = moebius_product(candidate, moebius_rot1);
            p = moebius_apply(moebius_rot3, p);
            candidate_fp = pgl_fp_product(candidate_fp, pgl_fp_rot1);
        } else if ( p[1]<-p[0] ) {
            candidate = moebius_product(candidate, moebius_rot3);
            p = moebius_apply(moebius_rot1, p);
            candidate_fp = pgl_fp_product(candidate_fp, pgl_fp_rot3);
        }
        // Examine whether we crossed the edge.
        var candidate2 = moebius_product(candidate, moebius_tflip);
        var p2 = moebius_apply(moebius_tflip, p);
        var candidate2_fp = pgl_fp_product(candidate_fp, pgl_fp_tflip);
        if ( p2[0]*p2[0] + p2[1]*p2[1] < p[0]*p[0] + p[1]*p[1] ) {
            // We crossed the edge (or at least, attempted to).
            candidate = candidate2;
            candidate_fp = candidate2_fp;
            p = p2;
            changed_square = true;
        } else
            break;
    }
    // Update position and such.
    current = candidate;
    moebius_renormalize (current);
    current_fp = candidate_fp;
    if ( do_bread_crumbs )
        put_bread_crumb (current_fp);
    if ( changed_square )
        did_move();
    draw_all();
}

function recenter() {
    "use strict";
    var p = moebius_apply(current, [1, 0]);
    if ( p[1]>p[0] && p[1]<-p[0] )
        current = moebius_rot2;
    else if ( p[1]>p[0] )
        current = moebius_rot1;
    else if ( p[1]<-p[0] )
        current = moebius_rot3;
    else
        current = moebius_idn;
    draw_all();
}

// Chrome doesn't define KeyEvent. :-(
var KE;
if ( typeof(KeyEvent) == "undefined" )
    KE = {};
else
    KE = KeyEvent;
if ( typeof(KE.DOM_VK_SPACE) == "undefined" ) {
    KE.DOM_VK_LEFT = 37;
    KE.DOM_VK_RIGHT = 39;
    KE.DOM_VK_UP = 38;
    KE.DOM_VK_DOWN = 40;
    KE.DOM_VK_INSERT = 45;
    KE.DOM_VK_DELETE = 46;
    KE.DOM_VK_F1 = 112;
    KE.DOM_VK_F2 = 113;
}

// To make things more pleasant, make sure dist_step is exactly 1/12
// of the distance between two cell centers.
var dist_step = 0.08843958849208630433608490968446445715056545824489;

var keyListener = function(e) {
    "use strict";
//    alert("Debug: "+e.keyCode);
    if ( e.keyCode == KE.DOM_VK_LEFT ) {
        if ( e.shiftKey )
            rotate(Math.PI/2);
        else
            rotate(Math.PI/20);
        e.preventDefault();
    } else if ( e.keyCode == KE.DOM_VK_RIGHT ) {
        if ( e.shiftKey )
            rotate(-Math.PI/2);
        else
            rotate(-Math.PI/20);
        e.preventDefault();
    } else if ( e.keyCode == KE.DOM_VK_UP ) {
        if ( e.shiftKey )
            move(dist_step*12, 1, 0);
        else
            move(dist_step, 1, 0);
        e.preventDefault();
    } else if ( e.keyCode == KE.DOM_VK_DOWN ) {
        if ( e.shiftKey )
            move(-dist_step*12, 1, 0);
        else
            move(-dist_step, 1, 0);
        e.preventDefault();
    } else if ( e.keyCode == KE.DOM_VK_INSERT ) {
        if ( e.shiftKey )
            move(dist_step*12, 0, 1);
        else
            move(dist_step, 0, 1);
        e.preventDefault();
    } else if ( e.keyCode == KE.DOM_VK_DELETE ) {
        if ( e.shiftKey )
            move(-dist_step*12, 0, 1);
        else
            move(-dist_step, 0, 1);
        e.preventDefault();
    } else if ( e.keyCode == KE.DOM_VK_F1 ) {
        recenter();
        e.preventDefault();
    }
};

// Chrome doesn't send keypress events for special keys. :-(
document.addEventListener("keydown", keyListener, false);

function canvasClickHandler(e) {
    "use strict";
    var x = e.pageX - canvas.offsetLeft;
    var y = e.pageY - canvas.offsetTop;
    // alert("click at ("+x+","+y+")");
    x -= canvas.width/2;
    y -= canvas.height/2;
    x /= scale;  y /= scale;
    var nrm = Math.sqrt(x*x + y*y);
    if ( nrm > 0 ) {
        x /= nrm;  y /= nrm;
        move(dist_step, -y, -x);
    }
    e.preventDefault();
}
canvas.addEventListener("click", canvasClickHandler, false);
canvas.addEventListener("mousedown", function(e) {
    e.preventDefault();  // Avoid text selection
}, false);

document.addEventListener("DOMContentLoaded", function(evt) {
    "use strict";
    var node = document.getElementById("explanations");
    if ( location.hash == "#explanations" )
        node.style.display = "block";
    document.getElementById("show-explanations").addEventListener("click", function(e) {
        if ( node.style.display == "block" ) {
            node.style.display = "none";
            location.hash = "";
            e.preventDefault();
        } else
            node.style.display = "block";
    }, false);
}, false);

// ]]>

</script>

<p>&#x2731; There is also <a href="hyperbolic-maze.html">a similar but
different game</a> (more of a classical maze) in the same world.</p>

<div id="explanations">

<h2>Some comments about this maze</h2>

<p>This is a maze in
the <a href="http://en.wikipedia.org/wiki/Hyperbolic_geometry">hyperbolic
plane</a>, displayed using
the <a href="http://en.wikipedia.org/wiki/Poincar%C3%A9_disk_model">Poincaré
disk</a>
or <a href="http://en.wikipedia.org/wiki/Beltrami%E2%80%93Klein_model">Beltrami-Klein</a>
model (see <a href="http://www.youtube.com/watch?v=xHvAqDuWG2M">this
video</a> for explanations and illustrations about projections of the
hyperbolic plane).  The fundamental pattern used to construct the maze
is <a href="http://commons.wikimedia.org/wiki/File:Uniform_tiling_45-t0.png">the
uniform tiling</a> of the hyperbolic plane by regular quadrilaterals
(“squares”?) with angles of 2<var>π</var>/5=72° at each vertex (less
than the 90° of a Euclidean square because the hyperbolic plane is
negatively curved).</p>

<p>There are no obstacles of any kind in this maze, making obvious the
fact that the hyperbolic plane is intrinsically mazelike, or at least,
tree-like.  (Specifically, going forward in two slightly different
directions, or even in “parallel” directions from two slightly spaced
points, will produce divergent trajectories, hence different regions
that can be explored.)</p>

<p>Use the up and down arrows to move up and down, left and right to
rotate left and right, and insert and delete to move left and right
without turning.  (Note that since the hyperbolic plane has curvature,
even if
one <a href="http://en.wikipedia.org/wiki/Parallel_transport">moves
without turning</a>, one can return to one's starting point with a
different orientation.  So it would be meaningless to have a “compass”
in the hyperbolic plane.)</p>

<p>Since the hyperbolic plane is infinite, the maze has been made
“periodic”, in much the same way that the Euclidean plane can be made
“periodic”, that is, transformed into a flat torus by quotienting by
a <a href="http://en.wikipedia.org/wiki/Lattice_(group)">lattice</a>
of periods, typically a square lattice in computer games, so that one
“loops around” if one goes to far.  Here something analogous has been
done, by quotienting out by
a <a href="http://en.wikipedia.org/wiki/Fuchsian_group">discrete
subgroup</a> <var>Γ</var>, acting without fixed points, of the
group <a href="http://en.wikipedia.org/wiki/SL2(R)">PSL(2,ℝ)</a> of
orientation-preserving isometries of the hyperbolic plane which is
contained in the group <var>Δ</var> of symmetries of the tiling (the
(2,4,5) <a href="http://en.wikipedia.org/wiki/Triangle_group">triangle
group</a>); here, <var>Γ</var> is a normal subgroup and
the quotient (PSL(2,ℝ)∩<var>Δ</var>)/<var>Γ</var> is
the <a href="http://en.wikipedia.org/wiki/Projective_linear_group">projective
special linear</a> group PSL(2,89) on
the <a href="http://en.wikipedia.org/wiki/Finite_field">finite
field</a> with 89 elements: since #PSL(2,89) = 352440, the period
domain consists of 88110 cells (each cell has 4 orientation-preserving
symmetries because it is a square), 176220 edges (each edge has 2
orientation-preserving symmetries) and 70488 vertices (each vertex has
5 orientation-preserving symmetries).  If one prefers, the maze lives
on a
compact <a href="http://en.wikipedia.org/wiki/Riemann_surface">Riemann
surface</a>
of <a href="http://en.wikipedia.org/wiki/Genus_(mathematics)">genus</a>
8812 (having 352440 symmetries),
whose <a href="http://en.wikipedia.org/wiki/Covering_space">universal
cover</a> is the hyperbolic plane (and <var>Γ</var> is its fundamental
group).  Or on
the <a href="http://en.wikipedia.org/wiki/Cayley_graph">Cayley
graph</a> of PSL(2,89) for two generators <var>R</var> (rotation
around a cell) and <var>T</var> (translation to the next cell).</p>

<p class="sidenote">The number 89 was chosen because it is the
smallest mod which the three
polynomials <var>X</var>⁴+1, <var>X</var>⁴−(3/2)<var>X</var>²+(1/4)
and <var>X</var>⁴+(1/2)<var>X</var>²−(1/4) <a href="http://en.wikipedia.org/wiki/Splitting_of_prime_ideals_in_Galois_extensions">split</a>
completely (they are the minimal polynomials of the coefficients
of <var>R</var> and <var>T</var> as elements of PSL(2,ℝ)), making it
possible to define <var>R</var> and <var>T</var> in
PSL(2,<var>F</var>) without requiring any extension.</p>

<p>To summarize the above, the maze world is large (consisting of
88110 square cells), although not infinite; but since there are a huge
number of intrinsically different ways of “wrapping back” to one's
starting point (the surface being of genus 8812), it is quite complex
and difficult to describe.</p>

<p>Twenty-four orbs have been placed regularly on the surface (they
have been placed at elements of a double
coset <var>x</var>·<var>H</var>·<var>y</var> where <var>H</var> is a
subgroup of PSL(2,89) isomorphic to the symmetric group on 4 objects),
and colored domains have been constructed around them at random, of
roughly the same size.  The goal of the game is to collect all these
orbs (by simply walking on the corresponding square).  Or one can just
explore around to get a feeling of what hyperbolic geometry looks
like.</p>

</div>

<hr />

<address><a href="http://www.madore.org/~david/">David Madore</a></address>

</body>
</html>
